<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HikoGUI: v1::loop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="version_dropdown.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HikoGUI
   </div>
   <div id="projectbrief">A low latency retained GUI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="a02244.html">v1</a></li><li class="navelem"><a href="a04703.html">loop</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">v1::loop Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:impl_5Ftype" id="r_impl_5Ftype"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="a04707.html">impl_type</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6dadd9bb37127f37847f29e378e03eb" id="r_ad6dadd9bb37127f37847f29e378e03eb"><td class="memItemLeft"><a id="ad6dadd9bb37127f37847f29e378e03eb" name="ad6dadd9bb37127f37847f29e378e03eb"></a>
using&#160;</td><td class="memItemRight"><b>timer_callback_token</b> = <a class="el" href="a04695.html">function_timer</a>&lt;&gt;<a class="el" href="a04695.html">::callback_token</a></td></tr>
<tr class="memitem:a4f425bc5558f9eb185ff71387f614b33" id="r_a4f425bc5558f9eb185ff71387f614b33"><td class="memItemLeft"><a id="a4f425bc5558f9eb185ff71387f614b33" name="a4f425bc5558f9eb185ff71387f614b33"></a>
using&#160;</td><td class="memItemRight"><b>render_callback_type</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt;void(utc_nanoseconds)&gt;</td></tr>
<tr class="memitem:a21ace86e67346ff9856f8a7bc597c25c" id="r_a21ace86e67346ff9856f8a7bc597c25c"><td class="memItemLeft"><a id="a21ace86e67346ff9856f8a7bc597c25c" name="a21ace86e67346ff9856f8a7bc597c25c"></a>
using&#160;</td><td class="memItemRight"><b>render_callback_token</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;render_callback_type&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add57f9f6970689f4b65c302b99e01480" id="r_add57f9f6970689f4b65c302b99e01480"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> ()</td></tr>
<tr class="memdesc:add57f9f6970689f4b65c302b99e01480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a loop.  <br /></td></tr>
<tr class="memitem:a5f24f2822056d5bce8c2c9054d684ee4" id="r_a5f24f2822056d5bce8c2c9054d684ee4"><td class="memItemLeft"><a id="a5f24f2822056d5bce8c2c9054d684ee4" name="a5f24f2822056d5bce8c2c9054d684ee4"></a>
&#160;</td><td class="memItemRight"><b>loop</b> (loop const &amp;)=delete</td></tr>
<tr class="memitem:a055e2afc01710c19ff7fc8ba72443569" id="r_a055e2afc01710c19ff7fc8ba72443569"><td class="memItemLeft"><a id="a055e2afc01710c19ff7fc8ba72443569" name="a055e2afc01710c19ff7fc8ba72443569"></a>
&#160;</td><td class="memItemRight"><b>loop</b> (loop &amp;&amp;) noexcept=default</td></tr>
<tr class="memitem:ac98777b4053cf2a419bb51035b441474" id="r_ac98777b4053cf2a419bb51035b441474"><td class="memItemLeft"><a id="ac98777b4053cf2a419bb51035b441474" name="ac98777b4053cf2a419bb51035b441474"></a>
<a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> const &amp;)=delete</td></tr>
<tr class="memitem:a60776c5fc1fbe6e5fa6482a491a7faec" id="r_a60776c5fc1fbe6e5fa6482a491a7faec"><td class="memItemLeft"><a id="a60776c5fc1fbe6e5fa6482a491a7faec" name="a60776c5fc1fbe6e5fa6482a491a7faec"></a>
<a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memitem:ab5d873b5309c718f8e98085f08947a4e" id="r_ab5d873b5309c718f8e98085f08947a4e"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ab5d873b5309c718f8e98085f08947a4e">set_maximum_frame_rate</a> (double frame_rate) noexcept</td></tr>
<tr class="memdesc:ab5d873b5309c718f8e98085f08947a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum frame rate.  <br /></td></tr>
<tr class="memitem:a6a8e5b2e665fa9487191814f082dac81" id="r_a6a8e5b2e665fa9487191814f082dac81"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6a8e5b2e665fa9487191814f082dac81">set_vsync_monitor_id</a> (uintptr_t id) noexcept</td></tr>
<tr class="memdesc:a6a8e5b2e665fa9487191814f082dac81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the monitor id for vertical sync.  <br /></td></tr>
<tr class="memitem:abb68768f17b944c6dec347310698d162" id="r_abb68768f17b944c6dec347310698d162"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#abb68768f17b944c6dec347310698d162">wfree_post_function</a> (auto &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:abb68768f17b944c6dec347310698d162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait-free post a function to be called from the loop.  <br /></td></tr>
<tr class="memitem:aca794bf41c3f5c9664be864ee1a70d6e" id="r_aca794bf41c3f5c9664be864ee1a70d6e"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aca794bf41c3f5c9664be864ee1a70d6e">post_function</a> (auto &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:aca794bf41c3f5c9664be864ee1a70d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a function to be called from the loop.  <br /></td></tr>
<tr class="memitem:a32f280b366ad7aa971dfbeb700caf5e3" id="r_a32f280b366ad7aa971dfbeb700caf5e3"><td class="memItemLeft">auto&#160;</td><td class="memItemRight"><a class="el" href="#a32f280b366ad7aa971dfbeb700caf5e3">async_function</a> (auto &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:a32f280b366ad7aa971dfbeb700caf5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function from the loop.  <br /></td></tr>
<tr class="memitem:a40c23806d7c1cf3c4742902e2dbb9713" id="r_a40c23806d7c1cf3c4742902e2dbb9713"><td class="memItemLeft">timer_callback_token&#160;</td><td class="memItemRight"><a class="el" href="#a40c23806d7c1cf3c4742902e2dbb9713">delay_function</a> (utc_nanoseconds time_point, auto &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:a40c23806d7c1cf3c4742902e2dbb9713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function at a certain time.  <br /></td></tr>
<tr class="memitem:afd278e644872a533d4a7c65cece447d2" id="r_afd278e644872a533d4a7c65cece447d2"><td class="memItemLeft">timer_callback_token&#160;</td><td class="memItemRight"><a class="el" href="#afd278e644872a533d4a7c65cece447d2">repeat_function</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> period, utc_nanoseconds time_point, auto &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:afd278e644872a533d4a7c65cece447d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function repeatedly.  <br /></td></tr>
<tr class="memitem:acdd4e626f26ffa9dd54897a55ec6bab9" id="r_acdd4e626f26ffa9dd54897a55ec6bab9"><td class="memItemLeft">timer_callback_token&#160;</td><td class="memItemRight"><a class="el" href="#acdd4e626f26ffa9dd54897a55ec6bab9">repeat_function</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> period, auto &amp;&amp;func) noexcept</td></tr>
<tr class="memdesc:acdd4e626f26ffa9dd54897a55ec6bab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function repeatedly.  <br /></td></tr>
<tr class="memitem:aba9c1a0d9a15910cc3be639073da9a4a" id="r_aba9c1a0d9a15910cc3be639073da9a4a"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aba9c1a0d9a15910cc3be639073da9a4a">subscribe_render</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/weak_ptr.html">std::weak_ptr</a>&lt; render_callback_type &gt; f) noexcept</td></tr>
<tr class="memdesc:aba9c1a0d9a15910cc3be639073da9a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a render function to be called on vsync.  <br /></td></tr>
<tr class="memitem:adbfc7feb0928e78a4c939e72b2f09323" id="r_adbfc7feb0928e78a4c939e72b2f09323"><td class="memTemplParams" colspan="2">template&lt;std::invocable&lt; utc_nanoseconds &gt; F&gt; </td></tr>
<tr class="memitem:adbfc7feb0928e78a4c939e72b2f09323 template"><td class="memItemLeft">render_callback_token&#160;</td><td class="memItemRight"><a class="el" href="#adbfc7feb0928e78a4c939e72b2f09323">subscribe_render</a> (F &amp;&amp;f) noexcept</td></tr>
<tr class="memdesc:adbfc7feb0928e78a4c939e72b2f09323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a render function to be called on vsync.  <br /></td></tr>
<tr class="memitem:aea9ef486570a5346997cdae79a1b3fec" id="r_aea9ef486570a5346997cdae79a1b3fec"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aea9ef486570a5346997cdae79a1b3fec">add_socket</a> (int fd, socket_event event_mask, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; void(int, <a class="el" href="a04719.html">socket_events</a> const &amp;)&gt; f)</td></tr>
<tr class="memdesc:aea9ef486570a5346997cdae79a1b3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback that reacts on a socket.  <br /></td></tr>
<tr class="memitem:ad2a91a3759db904705e6802fcd0fd29b" id="r_ad2a91a3759db904705e6802fcd0fd29b"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ad2a91a3759db904705e6802fcd0fd29b">remove_socket</a> (int fd)</td></tr>
<tr class="memdesc:ad2a91a3759db904705e6802fcd0fd29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the callback associated with a socket.  <br /></td></tr>
<tr class="memitem:a86e3ce8fd1bf0155d56fc7a793c213bb" id="r_a86e3ce8fd1bf0155d56fc7a793c213bb"><td class="memItemLeft">int&#160;</td><td class="memItemRight"><a class="el" href="#a86e3ce8fd1bf0155d56fc7a793c213bb">resume</a> (std::stop_token stop_token={}) noexcept</td></tr>
<tr class="memdesc:a86e3ce8fd1bf0155d56fc7a793c213bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the loop on the current thread.  <br /></td></tr>
<tr class="memitem:a0e170e6402f4a6b300cb296b2a6ff427" id="r_a0e170e6402f4a6b300cb296b2a6ff427"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a0e170e6402f4a6b300cb296b2a6ff427">resume_once</a> (bool block=false) noexcept</td></tr>
<tr class="memdesc:a0e170e6402f4a6b300cb296b2a6ff427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume for a single iteration.  <br /></td></tr>
<tr class="memitem:a1d7287a361fa9806730ceffefe5b2a06" id="r_a1d7287a361fa9806730ceffefe5b2a06"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a1d7287a361fa9806730ceffefe5b2a06">on_thread</a> () const noexcept</td></tr>
<tr class="memdesc:a1d7287a361fa9806730ceffefe5b2a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current thread is the same as the loop's thread.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a993aec4a2f7744f43a24422f5422b749" id="r_a993aec4a2f7744f43a24422f5422b749"><td class="memItemLeft">static hi_no_inline <a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a993aec4a2f7744f43a24422f5422b749">local</a> () noexcept</td></tr>
<tr class="memdesc:a993aec4a2f7744f43a24422f5422b749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create the thread-local loop.  <br /></td></tr>
<tr class="memitem:ad2820b7537c41ce13c1926bfcce1320a" id="r_ad2820b7537c41ce13c1926bfcce1320a"><td class="memItemLeft">static hi_no_inline <a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ad2820b7537c41ce13c1926bfcce1320a">main</a> () noexcept</td></tr>
<tr class="memdesc:ad2820b7537c41ce13c1926bfcce1320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create the main-loop.  <br /></td></tr>
<tr class="memitem:a30931318d990eb4a2bf7601119d81641" id="r_a30931318d990eb4a2bf7601119d81641"><td class="memItemLeft">static hi_no_inline <a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a30931318d990eb4a2bf7601119d81641">timer</a> () noexcept</td></tr>
<tr class="memdesc:a30931318d990eb4a2bf7601119d81641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create the timer event-loop.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add57f9f6970689f4b65c302b99e01480" name="add57f9f6970689f4b65c302b99e01480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add57f9f6970689f4b65c302b99e01480">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">v1::loop::loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a loop. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aea9ef486570a5346997cdae79a1b3fec" name="aea9ef486570a5346997cdae79a1b3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9ef486570a5346997cdae79a1b3fec">&#9670;&#160;</a></span>add_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::add_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socket_event</td>          <td class="paramname"><span class="paramname"><em>event_mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; void(int, <a class="el" href="a04719.html">socket_events</a> const &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback that reacts on a socket. </p>
<p>In most cases <em class="arg">mode</em> is set to one of the following values:</p><ul>
<li>error | read: Unblock when there is data available for read.</li>
<li>error | write: Unblock when there is buffer space available for write.</li>
<li>error | read | write: Unblock when there is data available for read of when there is buffer space available for write.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Only one callback can be associated with a socket. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor of the socket. </td></tr>
    <tr><td class="paramname">event_mask</td><td>The socket events to wait for. </td></tr>
    <tr><td class="paramname">f</td><td>The callback to call when the file descriptor unblocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32f280b366ad7aa971dfbeb700caf5e3" name="a32f280b366ad7aa971dfbeb700caf5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f280b366ad7aa971dfbeb700caf5e3">&#9670;&#160;</a></span>async_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto v1::loop::async_function </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function from the loop. </p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function from another thread. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call from the loop. The function must not take any argument, but may return a value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/future.html">std::future</a></span> for the return value. </dd></dl>

</div>
</div>
<a id="a40c23806d7c1cf3c4742902e2dbb9713" name="a40c23806d7c1cf3c4742902e2dbb9713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c23806d7c1cf3c4742902e2dbb9713">&#9670;&#160;</a></span>delay_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timer_callback_token v1::loop::delay_function </td>
          <td>(</td>
          <td class="paramtype">utc_nanoseconds</td>          <td class="paramname"><span class="paramname"><em>time_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function at a certain time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_point</td><td>The time at which to call the function. </td></tr>
    <tr><td class="paramname">func</td><td>The function to be called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a993aec4a2f7744f43a24422f5422b749" name="a993aec4a2f7744f43a24422f5422b749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993aec4a2f7744f43a24422f5422b749">&#9670;&#160;</a></span>local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hi_no_inline <a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp; v1::loop::local </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or create the thread-local loop. </p>

</div>
</div>
<a id="ad2820b7537c41ce13c1926bfcce1320a" name="ad2820b7537c41ce13c1926bfcce1320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2820b7537c41ce13c1926bfcce1320a">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hi_no_inline <a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp; v1::loop::main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or create the main-loop. </p>
<dl class="section note"><dt>Note</dt><dd>The first time <a class="el" href="#ad2820b7537c41ce13c1926bfcce1320a" title="Get or create the main-loop.">main()</a> is called must be from the main-thread. In this case there is no race condition on the first time <a class="el" href="#ad2820b7537c41ce13c1926bfcce1320a" title="Get or create the main-loop.">main()</a> is called. </dd></dl>

</div>
</div>
<a id="a1d7287a361fa9806730ceffefe5b2a06" name="a1d7287a361fa9806730ceffefe5b2a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7287a361fa9806730ceffefe5b2a06">&#9670;&#160;</a></span>on_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool v1::loop::on_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the current thread is the same as the loop's thread. </p>
<p>The loop's thread is the thread that calls <a class="el" href="#a86e3ce8fd1bf0155d56fc7a793c213bb" title="Resume the loop on the current thread.">resume()</a>. </p>

</div>
</div>
<a id="aca794bf41c3f5c9664be864ee1a70d6e" name="aca794bf41c3f5c9664be864ee1a70d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca794bf41c3f5c9664be864ee1a70d6e">&#9670;&#160;</a></span>post_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::post_function </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post a function to be called from the loop. </p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function from another thread. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call from the loop. The function must not take any arguments and return void. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2a91a3759db904705e6802fcd0fd29b" name="ad2a91a3759db904705e6802fcd0fd29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a91a3759db904705e6802fcd0fd29b">&#9670;&#160;</a></span>remove_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::remove_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the callback associated with a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor of the socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd4e626f26ffa9dd54897a55ec6bab9" name="acdd4e626f26ffa9dd54897a55ec6bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd4e626f26ffa9dd54897a55ec6bab9">&#9670;&#160;</a></span>repeat_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timer_callback_token v1::loop::repeat_function </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a></td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function repeatedly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The period between calls to the function. </td></tr>
    <tr><td class="paramname">func</td><td>The function to be called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd278e644872a533d4a7c65cece447d2" name="afd278e644872a533d4a7c65cece447d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd278e644872a533d4a7c65cece447d2">&#9670;&#160;</a></span>repeat_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">timer_callback_token v1::loop::repeat_function </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a></td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utc_nanoseconds</td>          <td class="paramname"><span class="paramname"><em>time_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function repeatedly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The period between calls to the function. </td></tr>
    <tr><td class="paramname">time_point</td><td>The time at which to call the function. </td></tr>
    <tr><td class="paramname">func</td><td>The function to be called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86e3ce8fd1bf0155d56fc7a793c213bb" name="a86e3ce8fd1bf0155d56fc7a793c213bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e3ce8fd1bf0155d56fc7a793c213bb">&#9670;&#160;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int v1::loop::resume </td>
          <td>(</td>
          <td class="paramtype">std::stop_token</td>          <td class="paramname"><span class="paramname"><em>stop_token</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume the loop on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_token</td><td>The thread's stop token to use to determine when to stop. If not stop token is given, then resume will automatically stop when there are no more windows, sockets, functions or timers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit code when the loop is exited. </dd></dl>

</div>
</div>
<a id="a0e170e6402f4a6b300cb296b2a6ff427" name="a0e170e6402f4a6b300cb296b2a6ff427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e170e6402f4a6b300cb296b2a6ff427">&#9670;&#160;</a></span>resume_once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::resume_once </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>block</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume for a single iteration. </p>
<p>The <span class="tt">resume_once(false)</span> may be used to continue processing events and GUI redraws while the GUI event queue is blocked. This happens on win32 when a window is being moved, resized, the title bar or system menu being clicked.</p>
<p>It should be called often, as it will be used to process network messages and latency of network processing will be increased based on the amount of times this function is called.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called from the same thread as <span class="tt"><a class="el" href="#a86e3ce8fd1bf0155d56fc7a793c213bb" title="Resume the loop on the current thread.">resume()</a></span>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Allow processing to block, this is normally done only inside <span class="tt"><a class="el" href="#a86e3ce8fd1bf0155d56fc7a793c213bb" title="Resume the loop on the current thread.">resume()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5d873b5309c718f8e98085f08947a4e" name="ab5d873b5309c718f8e98085f08947a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d873b5309c718f8e98085f08947a4e">&#9670;&#160;</a></span>set_maximum_frame_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::set_maximum_frame_rate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>frame_rate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum frame rate. </p>
<p>A frame rate above 30.0 may will cause the vsync thread to block on</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_rate</td><td>The maximum frame rate that a window will be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a8e5b2e665fa9487191814f082dac81" name="a6a8e5b2e665fa9487191814f082dac81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8e5b2e665fa9487191814f082dac81">&#9670;&#160;</a></span>set_vsync_monitor_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::set_vsync_monitor_id </td>
          <td>(</td>
          <td class="paramtype">uintptr_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the monitor id for vertical sync. </p>

</div>
</div>
<a id="adbfc7feb0928e78a4c939e72b2f09323" name="adbfc7feb0928e78a4c939e72b2f09323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfc7feb0928e78a4c939e72b2f09323">&#9670;&#160;</a></span>subscribe_render() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::invocable&lt; utc_nanoseconds &gt; F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">render_callback_token v1::loop::subscribe_render </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe a render function to be called on vsync. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function to be called when vsync occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba9c1a0d9a15910cc3be639073da9a4a" name="aba9c1a0d9a15910cc3be639073da9a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9c1a0d9a15910cc3be639073da9a4a">&#9670;&#160;</a></span>subscribe_render() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::subscribe_render </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/weak_ptr.html">std::weak_ptr</a>&lt; render_callback_type &gt;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe a render function to be called on vsync. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A weak pointer to a function to be called when vsync occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30931318d990eb4a2bf7601119d81641" name="a30931318d990eb4a2bf7601119d81641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30931318d990eb4a2bf7601119d81641">&#9670;&#160;</a></span>timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hi_no_inline <a class="el" href="#add57f9f6970689f4b65c302b99e01480">loop</a> &amp; v1::loop::timer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or create the timer event-loop. </p>
<dl class="section note"><dt>Note</dt><dd>The first time this is called a thread is started to handle the timer events. </dd></dl>

</div>
</div>
<a id="abb68768f17b944c6dec347310698d162" name="abb68768f17b944c6dec347310698d162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb68768f17b944c6dec347310698d162">&#9670;&#160;</a></span>wfree_post_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void v1::loop::wfree_post_function </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait-free post a function to be called from the loop. </p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function from another thread. </dd>
<dd>
The event loop is not directly notified that a new function exists and will be delayed until after the loop has woken for other work. </dd>
<dd>
The post is only wait-free if the function fifo is not full, and the function is small enough to fit in a slot on the fifo. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call from the loop. The function must not take any arguments and return void. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hikogui/src/hikogui/dispatch/<a class="el" href="a01865_source.html">loop_intf.hpp</a></li>
<li>hikogui/src/hikogui/dispatch/<a class="el" href="a01862_source.html">loop_win32_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.8-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for HikoGUI by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1
</small></address>
<script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
    primaryColor: '#f4f4ff',
    secondaryColor: 'rgba(244,244,255,0.9)',
    tertiaryColor: '#F9FAFC',
    },
});
</script>
</body>
</html>
</html>
